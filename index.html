<html>

<head>
<style>

:root {
  --card-size: 20vmin;
}

body {
    overscroll-behavior: none;
    overflow-x: hidden;
}

.cardButton {
    display: inline-block;
    width: var(--card-size);
    aspect-ratio: 1 / 1;
    border: 1px solid black;
    position: relative;
    cursor: pointer;
    background-color: white;
    user-select:none;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
}

.cardButtonText {
    position:absolute;
    top: 50%;
    right: 50%;
    transform: translate(50%, -50%);
    cursor: pointer;
    font-size:calc(0.7*var(--card-size));
    user-select:none;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
}

.cardButton.selected {
    background-color: lightgreen;
}

.button {
  background-color: #04AA6D;
  border: 1px solid green;
  color: white;
  padding: 1vmin 2vmin;
  text-align: center;
  text-decoration: none;

  font-size: 5vmin;
  cursor: pointer;
  display: inline-block;
  user-select: none;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}

#startRoundButton {
    font-size:8vmin;
}

#topBar {
    margin-bottom: 1vmin;
}

#cardRows {
    border-top: 1vmin solid #444;
    border-bottom: 1vmin solid #444;
    padding-top:2vmin;
    padding-bottom: 2vmin;
    min-height:calc(min(30vh,90vw));
}

#cardRows.gameOver {
    min-height: unset;
}

#howToPlayButton {
    background-color: #888;
    border: 0px;
    font-size: 5vmin;
}

#statsButton {
    background-color: #888;
    border: 0px;
    font-size: 5vmin;
}

#roundInProgressButtons .button {
    font-size:8vmin;
    padding: 3vmin 2vmin;
}


#roundInProgressButtons {
    white-space: nowrap;
} 

#roundInProgressSummary {
    padding: 1vmin 2vmin;
    font-size:6vmin;
    margin: 1vmin auto;
}

#gameDisplay {
    text-align:center;
}

.youLoseTable {
    display: inline-block;
}
.youLoseTable td {
    padding: 1vmin 1vmin;
}

.loseWarning {
    display: inline-block;
    color: red;
    font-weight: bold;
    font-size: 6vmin;
}

.youWinLabel {
    display: inline-block;
    color: green;
    font-weight: bold;
    font-size: 6vmin;
}

.solutionList {
    text-align: right;
    display: inline-block;
}

table.statsTable {
    border-collapse: collapse;
}

table.statsTable th {
    border: 1px solid black;
    padding: 2vmin;
}

table.statsTable td {
    border: 1px solid black;
    text-align: center;
    white-space: nowrap;
    padding: 2vmin;
}

#statsDisplay {
  position:relative;
  width: fit-content;
}

.closeModal {
  position: absolute;
  right: 0;
  top: 0;
  height: 1.5rem;
  width: 1.5rem;
  border : 0.1rem solid red;
  cursor: pointer;
}
.closeModal:before, .closeModal:after {
  position: absolute;
  left: 0.7rem;
  content: ' ';
  height: 1.5rem;
  width: 0.1rem;
  background-color: red;
}
.closeModal:before {
  transform: rotate(45deg);
}
.closeModal:after {
  transform: rotate(-45deg);
}

.statsHeaderButton {
    color:black;
    display:  inline-block;
    border:  1px solid black;
    margin: 0px 5px 3px 5px;
    padding: 3px 5px;
    cursor:  pointer;
    user-select: none;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    background: #ddd;
    font-weight: bold;
}

.statsheaderButton.selected {
    border-bottom-width: 0;
    background: #fff;
    text-decoration: underline;
}

.timestamp {
    color: #888;
    font-size: 0.8rem;
}

#recordsContent {
    width: fit-content;
}

.recordCategory {
    margin-bottom: 10px;
    background: #f0f0f0;
    padding: 5px 10px;
    border-radius: 10px;
}

.recordCategoryHeader {
    font-weight: bold;;
}

.singleGameCardHistory {
    margin-left: 5px;
    display: inline-block;
}

.singleCardFromHistory {
    display: inline-block;
    border: 1px solid #ccc;
    padding: 1px 2px;
    margin: 1px 1px;
    vertical-align: top;
}

.singleCardFromHistory.ignored {
    background-color: #e0e0e0;
    margin-top: 4px;
}

.singleCardFromHistory.added {
    background-color: lightgreen;
    margin-top: 1px;
}

.singleCardFromHistory.subtracted {
    background-color: #d0ffd0;
    margin-top: 7px;
}

.alert {
    margin-top: 5px;
    margin-left: 10px;
    border: 1px solid green;
    padding: 3px 10px;
    background-color: lightgreen;
    font-family:  monospace;
    border-radius: 8px;
}

</style>


<script>
var game;

function initialize() {
    game = new CardGame();
    let previousStats = localStorage.getItem("CardGameStats");
    if (previousStats != null) {
        game.gameStats = GameStats.fromJson(JSON.parse(previousStats));
        game.updateStatsUI();
    }
    game.startNewRound();
}

let ordinals = ["0th","1st","2nd","3rd","4th","5th","6th","7th","8th","9th"];
function getOrdinal(rank) {
    if (rank < 10) return ordinals[rank];
    return rank + "th";
}

class SolutionSet {
    solutionStrings;
    solutions;

    constructor() {
        this.solutionStrings = new Set();
        this.solutions = [];
    }

    addSolution(solution) {
        let solutionString = solution.getAsText();
        if (! this.solutionStrings.has(solutionString)) {
            this.solutionStrings.add(solutionString);
            this.solutions.push(solution);
        }       
    }
    
    getSolutionCount() { return this.solutions.length; }

    getMinRequiredCards() {
        if (this.solutions.length == 0) return 0;
        let min = this.solutions[0].getCardCount();
        for (let i = 0; i < this.solutions.length; i++) {
            if (this.solutions[i].getCardCount() < min) min = this.solutions[i].getCardCount();
        }
        return min;
    }

    getMinRequiredSolutionSum() {
        if (this.solutions.length == 0) return 0;
        let min = this.solutions[0].getSumOfCards();
        for (let i = 0; i < this.solutions.length; i++) {
            if (this.solutions[i].getSumOfCards() < min) min = this.solutions[i].getSumOfCards();
        }
        return min;
    }
}

class GameSolution {
    addedCards;
    subtractedCards;

    constructor(addedCards, subtractedCards) {
        this.addedCards = addedCards;
        this.subtractedCards = subtractedCards;
    }

    getCardCount() { return this.addedCards.length + this.subtractedCards.length; }

    getAsText() {
        return this.addedCards.join(" + ") + " - " + this.subtractedCards.join(" - ")
    }

    getSumOfCards() {
        let sum = 0;
        for (let i = 0; i < this.addedCards.length; i++) { sum += this.addedCards[i] }
        for (let i = 0; i < this.subtractedCards.length; i++) { sum += this.subtractedCards[i] }
        return sum;
    }
}

class TopNRecord {
    n;
    topN;
    higherIsBetter;

    static fromJson(jsonObject) {
        let x = new TopNRecord();
        x.n = jsonObject.n;
        x.topN = jsonObject.topN;
        x.higherIsBetter = jsonObject.higherIsBetter;
        return x;
    }

    static create(n, higherIsBetter) {
        let x = new TopNRecord();
        x.n = n;
        x.higherIsBetter = higherIsBetter;
        x.topN = [];
        return x;
    }

    getRank(score) {
        let rank = 1;
        for (let i = 0; i < this.topN.length; i++) {
            if (this.higherIsBetter && this.topN[i].score > score) rank++;
            else if ((!this.higherIsBetter) && this.topN[i].score < score) rank++;
        }
        return rank;
    }

    getSingleRecordHtml(index) {
        let html = [];
        html.push("<div class='singleGameCardHistory'>");
        for (let i = 0; i < this.topN[index].allCards.length; i++) {
            let solutionClass = "ignored";
            if (this.topN[index].solution) {
                if (this.topN[index].solution[i] == "+") solutionClass = "added";
                if (this.topN[index].solution[i] == "-") solutionClass = "subtracted";
            }
            html.push("<div class='singleCardFromHistory " + solutionClass + "'>" 
                + this.topN[index].allCards[i] + "</div>");
        }
        html.push("</div>");
        return html.join(" ");
    }

    addGame(roundOutcome, score) {
        if (this.topN.length < this.n || (this.higherIsBetter && (score > this.topN[this.n-1].score)) ||
          ((! this.higherIsBetter) && (score < this.topN[this.n-1].score))) {

            this.topN.push({score : score, 
                allCards : roundOutcome.allCards, 
                solution : roundOutcome.chosenSolution , 
                timestamp : roundOutcome.timestamp });
            const higherIsBetter = this.higherIsBetter;
            this.topN.sort((a,b) => {
                let x = (a.score - b.score) * (higherIsBetter ? -1 : 1);
                if (x != 0) return x;
                return a.timestamp - b.timestamp;
            });
            if (this.topN.length > this.n) {
                this.topN.pop();
            }
            let rank = 1;
            for (let i = 0; i < this.topN.length; i++) {
                if (this.higherIsBetter) {
                    if (this.topN[i].score > score) rank++;
                } else {
                    if (this.topN[i].score < score) rank++;
                }
            }
            return rank;
        }
        return 0;
    }
}

class GameRecords {
    fastestSolutionsUsingNCards;
    fastestFullGamesWithNCardsDealt;
    mostCardsDealt;
    biggestSolutionSum;
    biggestForcedSolutionSum;
    mostSolutions;

    static fromJson(jsonObject) {
        if (jsonObject == undefined || jsonObject == null) return GameRecords.createNew();
        let x = GameRecords.createNew();
        if (jsonObject.fastestSolutionsUsingNCards) {
            for (let i = 0; i < 11; i++) {
                x.fastestSolutionsUsingNCards[i] = TopNRecord.fromJson(jsonObject.fastestSolutionsUsingNCards[i]);
            }
        }
        if (jsonObject.fastestFullGamesWithNCardsDealt) {
            for (let i = 0; i < 11; i++) {
                x.fastestFullGamesWithNCardsDealt[i] = TopNRecord.fromJson(jsonObject.fastestFullGamesWithNCardsDealt[i]);
            }
        }
        if (jsonObject.mostCardsDealt) x.mostCardsDealt = TopNRecord.fromJson(jsonObject.mostCardsDealt);
        if (jsonObject.biggestSolutionSum) x.biggestSolutionSum = TopNRecord.fromJson(jsonObject.biggestSolutionSum);
        if (jsonObject.biggestForcedSolutionSum) x.biggestForcedSolutionSum = TopNRecord.fromJson(jsonObject.biggestForcedSolutionSum);
        if (jsonObject.mostSolutions) x.mostSolutions = TopNRecord.fromJson(jsonObject.mostSolutions);
        return x;
    }

    static createNew() {
        let x = new GameRecords();
        x.fastestSolutionsUsingNCards = new Array(11);
        x.fastestFullGamesWithNCardsDealt = new Array(11);
        for (let i = 0; i < 11; i++) {
            x.fastestSolutionsUsingNCards[i] = TopNRecord.create(3, false);
            x.fastestFullGamesWithNCardsDealt[i] = TopNRecord.create(3, false);
        }
        x.mostCardsDealt = TopNRecord.create(3, true);
        x.biggestSolutionSum = TopNRecord.create(3, true);
        x.biggestForcedSolutionSum = TopNRecord.create(3, true);
        x.mostSolutions = TopNRecord.create(3, true);
        return x;
    }

    formatNewRecordAlert(rank, recordType, score) {
        return "<span style='color:gold'>&#x1F3C6;</span> <span style='font-weight:bold; font-size: 1.3rem;'>" 
            + getOrdinal(rank) + "</span> <span style='font-weight:bold'>Place</span><br />"
            + recordType + " : " + score;
    }

    updateRecords(roundOutcome) {
        let cardsDealt = roundOutcome.cardsDealt;
        let newRank = 0;
       
        if (roundOutcome.didPlayerWin) {
            let usedCardCount = roundOutcome.chosenSolution.filter(x => (x == "+" || x == "-")).length;
            let sumOfUsedCards = 0;
            for (let i = 0; i < roundOutcome.chosenSolution.length; i++) {
                if (roundOutcome.chosenSolution[i] != "0") sumOfUsedCards += roundOutcome.allCards[i];
            }

            newRank = this.fastestSolutionsUsingNCards[usedCardCount]
                .addGame(roundOutcome, roundOutcome.getTimeSpentOnLastCard());
            if (newRank > 0) {
                game.addAlert(this.formatNewRecordAlert(newRank, "Fastest Solution Using " + usedCardCount + " Cards",
                    (roundOutcome.getTimeSpentOnLastCard()/1000).toFixed(2) + " seconds"));
                    
            }
            newRank = this.fastestFullGamesWithNCardsDealt[cardsDealt].addGame(roundOutcome, roundOutcome.getTotalTime());
            if (newRank > 0) {
                game.addAlert(this.formatNewRecordAlert(newRank, "Fastest Win With " + cardsDealt + " Cards Dealt",
                    (roundOutcome.getTotalTime()/1000).toFixed(2) + " seconds"));
            }
            newRank = this.biggestSolutionSum.addGame(roundOutcome, sumOfUsedCards);
            if (newRank > 0) {
                game.addAlert(this.formatNewRecordAlert(newRank, "Biggest Sum of Cards Used", sumOfUsedCards));
            }
        }

        newRank = this.mostCardsDealt.addGame(roundOutcome, cardsDealt);
        if (newRank > 0) {
            game.addAlert(this.formatNewRecordAlert(newRank, "Most Cards Dealt", cardsDealt));
        }

        newRank = this.biggestForcedSolutionSum.addGame(roundOutcome, roundOutcome.solutions.getMinRequiredSolutionSum());
        if (newRank > 0) {
            game.addAlert(this.formatNewRecordAlert(newRank, "Highest Required Sum of Cards Needed To Solve", roundOutcome.solutions.getMinRequiredSolutionSum()));
        }
        newRank = this.mostSolutions.addGame(roundOutcome, roundOutcome.solutions.getSolutionCount());
        if (newRank > 0) {
            game.addAlert(this.formatNewRecordAlert(newRank, "Most Possible Solutions To A Puzzle", roundOutcome.solutions.getSolutionCount()));
        }
    }
}

class GameStats {
    // with exactly X cards shown, get count of outcomes (Win, CorrectlyDealNext, Lose) , and time spent
    outcomeCountsByNumberOfCardsDealt;
    timeSpentFrequencies;
    maxDealableCards;

    records;

    static fromJson(jsonObject) {
        let x = new GameStats();
        x.outcomeCountsByNumberOfCardsDealt = jsonObject.outcomeCountsByNumberOfCardsDealt;
        x.timeSpentFrequencies = jsonObject.timeSpentFrequencies;
        x.maxDealableCards = jsonObject.maxDealableCards;
        x.records = GameRecords.fromJson(jsonObject.records);
        return x;
    }

    static createNew(maxDealableCards) {
        let x = new GameStats();
        x.maxDealableCards = maxDealableCards;
        x.outcomeCountsByNumberOfCardsDealt = new Array(maxDealableCards+1);
        x.timeSpentFrequencies = new Array(maxDealableCards+1);
        for (let i = 0; i <= maxDealableCards; i++) {
            x.outcomeCountsByNumberOfCardsDealt[i] = {
                win : 0,
                correctlyChoseDeal : 0,
                lose : 0
            };
            x.timeSpentFrequencies[i] = new Array(300);
            x.timeSpentFrequencies[i].fill(0);
        }
        x.records = GameRecords.createNew();
        return x;
    }

    getStatsTableHtml() {
        let html = "<table class='statsTable'><tr><th>Cards Shown</th><th>Accuracy</th><th>Median Time (s)</th></tr>";
        let maxCardsSeen = 0;
        let medians = this.getMedianTimes();
        for (let i = 3; i <= this.maxDealableCards; i++) {
            let outcomes = this.outcomeCountsByNumberOfCardsDealt[i];
            let total = outcomes.win + outcomes.correctlyChoseDeal + outcomes.lose;
            if (total == 0) {
                break;
            }
            let success = outcomes.win + outcomes.correctlyChoseDeal;
            html += "<tr><td>" + i + "</td><td>" + success + " / " + total + " (" + (success / total * 100).toFixed(1) + " %)</td>";
            html += "<td>" + (medians[i] * 0.1).toFixed(1) + "</td></tr>";
            maxCardsSeen = i;
        }
        html += "</table>";
        return html;
    }
    
    getTotalWins() {
        let wins = 0;
        for (let i = 3; i <= this.maxDealableCards; i++) {
            wins += this.outcomeCountsByNumberOfCardsDealt[i].win;
        }
        return wins;
    }
    
    getTotalLosses() {
        let losses = 0;
        for (let i = 3; i <= this.maxDealableCards; i++) {
            losses += this.outcomeCountsByNumberOfCardsDealt[i].lose;
        }
        return losses;
    }

    addRoundOutcome(roundOutcome) {
        let cards = roundOutcome.allCards.length;
        for (let i = 3; i < cards; i++) {
            this.timeSpentFrequencies[i][Math.min(Math.floor(roundOutcome.timeSpentPerCard[i-1] / 100), 299)]++;
            this.outcomeCountsByNumberOfCardsDealt[i].correctlyChoseDeal = this.outcomeCountsByNumberOfCardsDealt[i].correctlyChoseDeal + 1;
        }
        this.timeSpentFrequencies[cards][Math.min(Math.floor(roundOutcome.timeSpentPerCard[cards-1] / 100), 299)]++;
        if (roundOutcome.didPlayerWin) {
            this.outcomeCountsByNumberOfCardsDealt[cards].win = this.outcomeCountsByNumberOfCardsDealt[cards].win + 1;
        } else {
            this.outcomeCountsByNumberOfCardsDealt[cards].lose = this.outcomeCountsByNumberOfCardsDealt[cards].lose + 1;
        }
        this.records.updateRecords(roundOutcome);

    }

    getMedianTimes() {
        let x = new Array(this.maxDealableCards+1);
        for (let i = 3; i <= this.maxDealableCards; i++) {
            let outcomes = this.outcomeCountsByNumberOfCardsDealt[i];
            let total = outcomes.win + outcomes.correctlyChoseDeal + outcomes.lose;
            if (total == 0) { x[i] = undefined; continue; }
            x[i] = this.getMedianIndexOfFrequencyArray(this.timeSpentFrequencies[i], total);
        }
        return x;
    }

    getMedianIndexOfFrequencyArray(x, sum) {
        let n = x.length;
        if (sum % 2 == 1) {
            let count = 0, target = (sum + 1)/2;
            for (let i = 0; i < n; i++) {
                count += x[i];
                if (count >= target) {
                    return i;
                }
            }
        } else {
            let count = 0, target = sum / 2;
            let leftMedian = 0, rightMedian = 0;
            for (let i = 0; i < n; i++) {
                count += x[i];
                if (count >= target) {
                    leftMedian = i; break;
                }
            }
            target += 1; count = 0;
            for (let i = 0; i < n; i++) {
                count += x[i];
                if (count >= target) {
                    rightMedian = i; break;
                }
            }
            return (leftMedian + rightMedian)/2;
        }
    }

}

class CardGame {
    currentRound;
    gameStats = GameStats.createNew(10);

    startNewRound() {
        document.getElementById("additionRow").innerHTML = "";
        document.getElementById("middleRow").innerHTML = "";
        document.getElementById("subtractionRow").innerHTML = "";
        document.getElementById("alerts").innerHTML = "";
        this.currentRound = new CardGameRound(this);
        this.currentRound.startRound();
    }

    reportRoundOutcome(roundOutcome) {
        //console.log(roundOutcome);
        this.gameStats.addRoundOutcome(roundOutcome);
        //console.log(this.gameStats);
        this.updateStatsUI();
        localStorage.setItem("CardGameStats", JSON.stringify(this.gameStats));
    }

    updateStatsUI() {
        let wins = this.gameStats.getTotalWins();
        let losses = this.gameStats.getTotalLosses();
        document.getElementById("statsButton").innerHTML = wins + " Win" + (wins == 1 ? "" : "s") + " | " + losses + (losses == 1 ? " Loss" : " Losses");
        document.getElementById("statsContent").innerHTML = this.gameStats.getStatsTableHtml();
    }

    showStatsModal() {
        document.getElementById("statsDisplay").style.display = "block";
        document.getElementById("gameDisplay").style.display = "none";
        this.showTab('stats');
    }

    hideStatsModal() {
        document.getElementById("statsDisplay").style.display = "none";
        document.getElementById("gameDisplay").style.display = "block";
    }

    addAlert(alertMessage) {
        let alert = document.createElement("div");
        alert.classList.add("alert");
        alert.innerHTML = alertMessage;            
        document.getElementById("alerts").appendChild(alert);
    }

    showTab(tabName) {
        let buttons = document.getElementById('statsHeader').getElementsByClassName('statsHeaderButton');
        for (let button of buttons) {
            button.classList.remove("selected");
        }
        document.getElementById(tabName + "TabButton").classList.add("selected");

        document.getElementById("statsContent").style.display = "none";
        document.getElementById("recordsContent").style.display = "none";

        if (tabName == 'records') {
            this.updateRecordsUI();
            document.getElementById("recordsContent").style.display = "block";
        }
        if (tabName == 'stats') {
            document.getElementById("statsContent").style.display = "block";
        }


    };

    updateRecordsUI() {
        let html = [];
        let records = game.gameStats.records;
        if (!records) return;
        let recs = records.fastestSolutionsUsingNCards;
        if (recs) {
            for (let i = 3; i < 11; i++) {
                if (recs[i].topN.length > 0) {
                    html.push("<div class='recordCategory'>");
                    html.push("<div class='recordCategoryHeader'>Fastest Solutions Using Exactly " + i + " Cards</div>");
                    for (let j = 0; j < recs[i].topN.length; j++) {
                        html.push((j > 0 ? "<br />" : "") + recs[i].getRank(recs[i].topN[j].score) + " : " 
                            + (recs[i].topN[j].score / 1000).toFixed(2) + " <span class=timestamp>[" 
                            + (new Date(recs[i].topN[j].timestamp)).toLocaleString() + "]</span>");
                        html.push(recs[i].getSingleRecordHtml(j));
                    }
                    html.push("</div>");

                }
            }
        }
        recs = records.fastestFullGamesWithNCardsDealt;
        if (recs) {
            for (let i = 3; i < 11; i++) {
                if (recs[i].topN.length > 0) {
                    html.push("<div class='recordCategory'>");
                    html.push("<div class='recordCategoryHeader'>Fastest Full Games With " + i + " Cards Dealt</div>");
                    for (let j = 0; j < recs[i].topN.length; j++) {
                        html.push((j > 0 ? "<br />" : "") + recs[i].getRank(recs[i].topN[j].score) + " : " 
                            + (recs[i].topN[j].score / 1000).toFixed(2) + " <span class=timestamp>[" 
                            + (new Date(recs[i].topN[j].timestamp)).toLocaleString() + "]</span>");
                        html.push(recs[i].getSingleRecordHtml(j));
                    }
                    html.push("</div>");
                }
            }
        }

        recs = records.biggestSolutionSum;
        if (recs) {
            if (recs.topN.length > 0) {
                html.push("<div class='recordCategory'>");
                html.push("<div class='recordCategoryHeader'>Biggest Sum of Cards Used</div>");
                for (let j = 0; j < recs.topN.length; j++) {
                    html.push((j > 0 ? "<br />" : "") + recs.getRank(recs.topN[j].score) + " : " + recs.topN[j].score + " <span class=timestamp>[" + 
                        (new Date(recs.topN[j].timestamp)).toLocaleString() + "]</span>");
                    html.push(recs.getSingleRecordHtml(j));
                }
                html.push("</div>");
            }
        }

        recs = records.mostCardsDealt;
        if (recs) {
            if (recs.topN.length > 0) {
                html.push("<div class='recordCategory'>");
                html.push("<div class='recordCategoryHeader'>Most Cards Dealt</div>");
                for (let j = 0; j < recs.topN.length; j++) {
                    html.push((j > 0 ? "<br />" : "") + recs.getRank(recs.topN[j].score) + " : " + recs.topN[j].score + " <span class=timestamp>[" + 
                        (new Date(recs.topN[j].timestamp)).toLocaleString() + "]</span>");
                    html.push(recs.getSingleRecordHtml(j));
                }
                html.push("</div>");
            }
        }

        recs = records.biggestForcedSolutionSum;
        if (recs) {
            if (recs.topN.length > 0) {
                html.push("<div class='recordCategory'>");
                html.push("<div class='recordCategoryHeader'>Highest Required Sum of Cards Needed To Solve</div>");
                for (let j = 0; j < recs.topN.length; j++) {
                    html.push((j > 0 ? "<br />" : "") + recs.getRank(recs.topN[j].score) + " : " + recs.topN[j].score + " <span class=timestamp>[" + 
                        (new Date(recs.topN[j].timestamp)).toLocaleString() + "]</span>");
                    html.push(recs.getSingleRecordHtml(j));
                }
                html.push("</div>");
            }
        }
        
        recs = records.mostSolutions;
        if (recs) {
            if (recs.topN.length > 0) {
                html.push("<div class='recordCategory'>");
                html.push("<div class='recordCategoryHeader'>Most Possible Solutions to a Puzzle</div>");
                for (let j = 0; j < recs.topN.length; j++) {
                    html.push((j > 0 ? "<br />" : "") + recs.getRank(recs.topN[j].score) + " : " + recs.topN[j].score + " <span class=timestamp>[" + 
                        (new Date(recs.topN[j].timestamp)).toLocaleString() + "]</span>");
                    html.push(recs.getSingleRecordHtml(j));
                }
                html.push("</div>");
            }
        }

        document.getElementById("recordsContent").innerHTML = html.join("\n");
    }
}

class RoundOutcome {
    allCards;
    timeSpentPerCard = [];
    didPlayerWin;
    cardsDealt;
    solutions;
    timestamp;
    chosenSolution;

    static create(allCards, timesWhenCardsDealt, didPlayerWin, cardsDealt, solutions, timestamp, chosenSolution) {
        let x = new RoundOutcome();
        for (let i = 0; i < timesWhenCardsDealt.length - 1; i++) {
            x.timeSpentPerCard.push(timesWhenCardsDealt[i+1] - timesWhenCardsDealt[i]);
        }
        x.allCards = allCards;
        x.didPlayerWin = didPlayerWin;
        x.cardsDealt = cardsDealt;
        x.solutions = solutions;
        x.timestamp = timestamp;
        x.chosenSolution = chosenSolution;
        return x;
    }

    getTotalTime() {
        let total = 0;
        for (let i = 0; i < this.timeSpentPerCard.length; i++) {
            total += this.timeSpentPerCard[i];
        }
        return total;
    }

    getTimeSpentOnLastCard() {
        return this.timeSpentPerCard[this.cardsDealt-1];
    }
}

class CardGameRound {
    allCards = [];
    cardsDealtCount = 0;
    targetSum = 10;
    additionButtons = [];
    middleButtons = [];
    subtractionButtons = [];
    currentGuess = []; // for each card that's dealt, this will contain "add", "subtract", or "ignore"
    solutions = new SolutionSet();
    roundOutcome;
    timesWhenCardsDealt = [];
    game;

    constructor(game) {
        this.game = game;
    }
    
    startRound() {
        document.getElementById("roundOverSummary").style.innerHTML = "";
        document.getElementById("roundOver").style.display = "none";
        document.getElementById("cardRows").classList.remove("gameOver");
        document.getElementById("roundInProgressSummary").innerHTML = "Add and subtract to make " + this.targetSum;
        document.getElementById("roundInProgressContent").style.display = "block";

        while(this.solutions.getSolutionCount() == 0) {
            this.allCards = [];
            while (this.allCards.length < 10 && this.solutions.getSolutionCount() == 0) {
                this.allCards.push(Math.floor(Math.random() * 10) + 1);
                this.solutions = this.findSolutions(this.allCards, this.targetSum);
            }
        }
        this.dealCard();
        this.dealCard();
        this.dealCard();
    }

    // action is 'add' , 'subtract', 'ignore'
    handleClick(clickEvent) {
        if (this.roundOutcome != undefined) return;
        let cardIndex = clickEvent.currentTarget.dataset.cardIndex;
        let action = clickEvent.currentTarget.dataset.action;
        this.currentGuess[cardIndex] = action;

        this.handleEquationUpdate();
    }

    handleEquationUpdate() {
        for (let cardIndex = 0; cardIndex < this.cardsDealtCount; cardIndex++) {
            this.additionButtons[cardIndex].classList.remove("selected");
            this.middleButtons[cardIndex].classList.remove("selected");
            this.subtractionButtons[cardIndex].classList.remove("selected");

            this.additionButtons[cardIndex].querySelector(".cardButtonText").innerHTML = "+";
            this.middleButtons[cardIndex].querySelector(".cardButtonText").innerHTML = "&osol;";
            this.subtractionButtons[cardIndex].querySelector(".cardButtonText").innerHTML = "-";
            if (this.currentGuess[cardIndex] == "add") {
                this.additionButtons[cardIndex].classList.add("selected");
                this.additionButtons[cardIndex].querySelector(".cardButtonText").innerHTML = this.allCards[cardIndex];
            }
            if (this.currentGuess[cardIndex] == "subtract") {
                this.subtractionButtons[cardIndex].classList.add("selected");
                this.subtractionButtons[cardIndex].querySelector(".cardButtonText").innerHTML = this.allCards[cardIndex];
            }
            if (this.currentGuess[cardIndex] == "ignore") {
                this.middleButtons[cardIndex].classList.add("selected");
                this.middleButtons[cardIndex].querySelector(".cardButtonText").innerHTML = this.allCards[cardIndex];
            }
        }

        let sum = 0, subtractedCount = 0, addedCount = 0;
        let textSummary = "", additionText = "", subtractionText = "";
        for(let i = 0; i < this.cardsDealtCount; i++) {
            if (this.currentGuess[i] == "add") {
                sum += this.allCards[i];
                addedCount++;
                if (additionText !== "") additionText += " + ";
                additionText += this.allCards[i];
            } 
            if (this.currentGuess[i] == "subtract") {
                sum -= this.allCards[i];
                subtractedCount++;
                if (subtractionText !== "") subtractionText += " - ";
                subtractionText += this.allCards[i];
            }
        }
        textSummary = additionText;
        if (subtractedCount > 0) textSummary += " - ";
        textSummary += subtractionText;
        if (sum == this.targetSum) {
            textSummary += " = ";
        } else {
            textSummary += " <span style='color:red;font-weight:bold'>  &ne; </span>";
        }
        textSummary += this.targetSum;

        if (sum == this.targetSum && subtractedCount == 0) {
            textSummary = "<span style='color:red;font-size:5vmin;'>(Need to subtract at least 1 number, too)</span>";
        }
        if (addedCount + subtractedCount == 0) {
            textSummary = "Add and subtract to make " + this.targetSum;
        }
        document.getElementById("roundInProgressSummary").innerHTML = textSummary;
        
        if (sum == this.targetSum && subtractedCount > 0) {
            this.handleWin();
            return;
        }
    }


    handleWin() {
        this.timesWhenCardsDealt.push(Date.now());
        this.roundOutcome = RoundOutcome.create(this.allCards, this.timesWhenCardsDealt, true /* win */, this.cardsDealtCount, this.solutions, Date.now(), this.getCurrentGuessShortForm());
        this.game.reportRoundOutcome(this.roundOutcome);

        
        document.getElementById("roundOverSummary").innerHTML = "<div class='youWinLabel'>You win !</div>";
        document.getElementById("roundOver").style.display = "block";
        document.getElementById("roundInProgressContent").style.display = "none";
        document.getElementById("cardRows").classList.add("gameOver");
    }

    handleLoss() {
        this.roundOutcome = RoundOutcome.create(this.allCards, this.timesWhenCardsDealt, false /* didn't win */, this.cardsDealtCount, this.solutions, Date.now(), null);
        this.game.reportRoundOutcome(this.roundOutcome);

        let target = this.targetSum;
        document.getElementById("roundOverSummary").innerHTML = "<table class='youLoseTable'><tr><td class='loseWarning'>You lose !</td><td class='solutionList'>"
            + this.solutions.solutions.slice(0,4).map(sol => sol.getAsText() + " = " + target).join("<br />\n")
            + (this.solutions.solutions.length > 4 ? ("<br />... (" + this.solutions.solutions.length + " solutions total)") : "") + "</td></tr></table>"
        document.getElementById("roundOver").style.display = "block";
        document.getElementById("roundInProgressContent").style.display = "none";
        document.getElementById("cardRows").classList.add("gameOver");
    }

    dealCard() {
        this.timesWhenCardsDealt.push(Date.now());

        if (this.cardsDealtCount == this.allCards.length) {
            this.handleLoss();
            return;
        }
        let cardSize = "calc(min(30vh/3,90vw/" + (this.cardsDealtCount+1)+"))";

        document.querySelector(':root').style.setProperty("--card-size", cardSize);

        let addButton = document.createElement("div");
        addButton.classList.add("cardButton");
        addButton.dataset.action = "add";
        addButton.dataset.cardIndex = this.cardsDealtCount;
        addButton.innerHTML = "<div class='cardButtonText'>+</div>";
        addButton.addEventListener('click', this.handleClick.bind(this));
        document.getElementById("additionRow").appendChild(addButton);
        this.additionButtons.push(addButton);

        let ignoreButton = document.createElement("div");
        ignoreButton.classList.add("cardButton");
        ignoreButton.dataset.action = "ignore";
        ignoreButton.dataset.cardIndex = this.cardsDealtCount;
        ignoreButton.addEventListener('click', this.handleClick.bind(this));
        ignoreButton.innerHTML = "<div class='cardButtonText'>" + this.allCards[this.cardsDealtCount] + "</div>";
        document.getElementById("middleRow").appendChild(ignoreButton);
        this.middleButtons.push(ignoreButton);

        let subtractButton = document.createElement("div");
        subtractButton.classList.add("cardButton");
        subtractButton.dataset.action = "subtract";
        subtractButton.dataset.cardIndex = this.cardsDealtCount;
        subtractButton.addEventListener('click', this.handleClick.bind(this));
        subtractButton.innerHTML = "<div class='cardButtonText'>-</div>";
        document.getElementById("subtractionRow").appendChild(subtractButton);
        this.subtractionButtons.push(subtractButton);

        this.cardsDealtCount++;
        this.currentGuess.push("ignore");
        this.resetEquation();
    }

    resetEquation() {
        this.currentGuess.fill("ignore");

        this.handleEquationUpdate();
    }

    findSolutions(cardHand, target) {
        let cardCount = cardHand.length;
        let totalPermutations = 3 ** cardCount; // ** is exponentiation
        let digit = 0, x = 0, d = 0, addedSum = 0, subtractedSum = 0;
        let solutions = new SolutionSet();
        for (let p = 0; p < totalPermutations; p++) {
            x = p;
            addedSum = 0; subtractedSum = 0;
            for (digit = 0; digit < cardCount; digit++) {
                d = x % 3; // 0 means not included, 1 means added, 2 means subtracted
                if (d == 1) addedSum += cardHand[digit];
                if (d == 2) subtractedSum += cardHand[digit];
                x = (x - d) / 3; // trim off the last digit (in base 3)
            }
            if (addedSum - subtractedSum == target && subtractedSum > 0) {
                // Found a solution. Now figure out which cards were in it.
                x = p;
                let addedCards = [], subtractedCards = [];
                for (digit = 0; digit < cardCount; digit++) {
                    d = x % 3; // 0 means not included, 1 means added, 2 means subtracted
                    if (d == 1) addedCards.push(cardHand[digit]);
                    if (d == 2) subtractedCards.push(cardHand[digit]);
                    x = (x - d) / 3; // trim off the last digit (in base 3)
                }
                addedCards.sort((a, b) => b - a); // descending order
                subtractedCards.sort((a, b) => b - a);
                solutions.addSolution(new GameSolution(addedCards, subtractedCards));          
            }
        }
        return solutions;
    }

    getCurrentGuessShortForm() {
        return this.currentGuess.map(x => {
            if (x == "add") return "+";
            if (x == "subtract") return "-";
            return "0";
        });
    }
}

</script>
</head>
<body onload="initialize();">

<div id="gameDisplay">
    <div id="topBar">
        <!-- <div id="howToPlayButton" class="button">How to Play ?</div> -->
        <div id="statsButton" class="button" onclick="game.showStatsModal();">0 Wins | 0 Losses </div>
    </div>
    <div id="roundDisplay">
        <div id="cardRows">
            <div style="white-space:nowrap" id="additionRow"></div>
            <div style="white-space:nowrap" id="middleRow"></div>
            <div style="white-space:nowrap" id="subtractionRow"></div>
        </div>
        <div id="roundInProgressContent">
            <div id="roundInProgressSummary"></div>
            <div id="roundInProgressButtons">
                <div onclick="game.currentRound.resetEquation();" class="button" id="resetButton">Reset</div>
                <div onclick="game.currentRound.dealCard();" class="button" id="dealCardButton">Deal Another Card</div>
            </div>
        </div>
    </div>

    <div id="roundOver">
        <div id="roundOverSummary"></div>
        <div onclick="game.startNewRound();" class="button" id="startRoundButton">Go Again</div>
        <div id="alerts"></div>
    </div>
    
</div>

<div id="statsDisplay" style="display:none">
    <div id="statsHeader">
        <div id="statsTabButton" class="statsHeaderButton" onclick="game.showTab('stats')">Stats</div>
        <div id="recordsTabButton"  class="statsHeaderButton" onclick="game.showTab('records')">Records</div>
        <div id="achievementsTabButton"  class="statsHeaderButton" onclick="game.showTab('achievements')">Achievements</div>
        <div id="closeStatsButton" class="closeModal" onclick="game.hideStatsModal();"></div>
    </div>

    <div id="statsContent"></div>
    <div id="recordsContent"></div>

</div>

</body>



</html>